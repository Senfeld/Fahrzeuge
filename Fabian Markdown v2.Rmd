---
title: "Fabian Markdown v2"
author: "Fabian"
date: "2024-03-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
install.packages("tidyverse")
library(tidyverse)
```


#Vorbereitung
Hier werden einige Vorbereitungen getroffen, um das einlesen zu vereinfachen. In *our_csv* ist schon festgelegt, welche CSV-Dateien für uns relevant sind, damit die Schleife direkt nach diesen suchen kann. Das gleiche für *our_txt*.
Eine Liste, in der die Dateien abgespeichert werden, wird ebenso initialisiert. 

```{r}
#RAM Speicherplatz auf 3GB einstellen
#Sys.setenv("VROOM_CONNECTION_SIZE" = "3GB")

#Hier eigenen Pfad für Dateien eingeben 
folder_path <- "./Einzelteil"

#Vektor, wo die für uns relevanten Einzelteile aufgelistet sind 
our_txt <- c("Einzelteil_T31.txt","Einzelteil_T36.txt","Einzelteil_T39.txt")
our_special_txt <- c("Einzelteil_T34.txt","Einzelteil_T35.txt")

our_csv <- c("Einzelteil_T30.csv","Einzelteil_T32.csv","Einzelteil_T33.csv","Einzelteil_T37.csv","Einzelteil_T38.csv","Einzelteil_T40.csv")

col_names_v1 <- c("","X1", "ID_T39.x", "Produktionsdatum.x", "Herstellernummer.x", "Werksnummer.x", 
               "Fehlerhaft.x", "Fehlerhaft_Datum.x", "Fehlerhaft_Fahrleistung.x", 
               "ID_T39.y", "Produktionsdatum.y", "Herstellernummer.y", "Werksnummer.y", 
               "Fehlerhaft.y", "Fehlerhaft_Datum.y", "Fehlerhaft_Fahrleistung.y")

col_names_v2 <- c( "","X1","ID_T36",  "Herstellernummer",  "Werksnummer",  "Fehlerhaft",  "Fehlerhaft_Datum" , "Fehlerhaft_Fahrleistung",  "Produktionsdatum_Origin_01011970",  "origin")

#Dateien mit Semikolon als Seperator
semiko_sep <- c("Einzelteil_T32.csv","Einzelteil_T40.csv")


#Erzeugung leere Liste für die Einzelteile
list_of_parts <- list()


```

#Einlesen der untersuchten Dateien
##Einlesen der CSV-Dateien und speichern in der Liste "list_of_parts"
Code spuckt Meldung aus, wenn bestimmte CSV nicht zur untersuchenden Gruppe gehört und unterscheidet zwischen Seperator ";" und ",". 
CSV- und TXT-Dateien werden gesondert eingelesen, da sich letztere als komplizierter erwiesen haben. 
```{r}

#Erstellung Vektor mit Dokumentennamen 
file_list_csv <- list.files(folder_path,pattern="*.csv")

for(file in file_list_csv){
  
  full_path <- paste0(folder_path, "/", file)
  
  if(file %in% our_csv){
    
  
    if(file.exists(full_path)){
      if(file %in% semiko_sep){
        
        #read_csv2 zum einlesen mit Semikolon-Trennzeichen 
        list_of_parts[[file]] <- read_csv2(full_path)
        
      }else{
        
        #read_csv zum einlesen mit Komma-Trennzeichen 
        list_of_parts[[file]] <- read_csv(full_path) 
        }
      
    }
    
      
    }else{ 
    
      print(paste(file,"gehört nicht zu den untersuchten .csv Daten"))
      next
    }
  
  }
  

```

##Einlesen der TXT-Dateien
```{r}

#Erstellung Vektor mit Dokumentennamen 
file_list_txt <- list.files(folder_path,pattern="*.txt")

for(file in file_list_txt){
  
   full_path <- paste0(folder_path, "/", file)
   
    if(file == "Einzelteil_T31.txt"){
      data <- readLines(full_path)
      
      #Ersetze Seperatoren und füge Zeilenumbruch ein 
      data <- str_replace_all(data, pattern = "  ", replacement = ";")
      data <- str_replace_all(data, pattern = "", replacement = "\n")
      
      #Füge Datei der Liste hinzu 
      list_of_parts[[file]] <- read.table(text = data, sep = ";", header = FALSE, skip = 1, stringsAsFactors = FALSE, col.names = col_names_v2)
      
    }
    else if(file == "Einzelteil_T36.txt"){
      data <- readLines(full_path)
      data <- str_replace_all(data, pattern = "  ", replacement = ";")
      data <- str_replace_all(data, pattern = " ", replacement = "\n")
      
      list_of_parts[[file]] <- read.table(text = data, sep = ";", header = FALSE, skip = 1, stringsAsFactors = FALSE,col.names = col_names_v2)
    }
    else if(file == "Einzelteil_T34.txt"){
      data <- readLines(full_path)
      
      list_of_parts[[file]] <- reading_T34(data)
      
    }
    else if(file == "Einzelteil_T35.txt"){
      data <- readLines(full_path)

      list_of_parts[[file]] <- reading_T35(data)
      
    }
    else if(file == "Einzelteil_T39.txt"){
      data <- readLines(full_path)
      data <- str_replace_all(data, pattern = fixed("\\"), replacement = ";")
      data <- str_replace_all(data, pattern = " ", replacement = "\n")
      #T39 setzt statt \n erstmal \a aus unerklärlichen Gründen, weshalb \a nochmal ersetzt werden muss 
      data <- str_replace_all(data, pattern = "\a", replacement = "\n")
      
      list_of_parts[[file]] <- read.table(text = data, sep = ";", header = FALSE, skip = 1, stringsAsFactors = FALSE, col.names = col_names_v1)
    
   }else{ 
    
      print(paste(file,"gehört nicht zu den untersuchten .txt Daten"))
      next
    }
  
  }
  

```
#Funktionen zum einlesen von T34 und T35
Diese beiden Dateien stellten eine besondere Herausforderung dar, da diese keinen eindeutigen Zeilenumbruch hatten. Hier musste also ein Muster identifiziert werden, vor welches jeweils ein Zeilenumbruch eingefügt werden sollte. 

###T34 Funktion
```{r}
reading_T34 <- function(data){
  
  gesamter_text <- paste(data, collapse = " ")


# Ersetzen der spezifischen Sequenz durch einen Zeilenumbruch (\n)
# Die Sequenz "\\\"\\d+\"\\\\\\d+\\\\" steht für eine ganze Zahl
# und wird durch einen Zeilenumbruch ersetzt, wobei wir die Sequenz selbst entfernen.
# Fügen \n vor der Sequenz ein, um den neuen Datensatz in einer neuen Zeile zu beginnen.
gesamter_text <- gsub("(?<!^)(\"\\d+-\\d+-\\d+-\\d+\" \\| \\| )", "\n\\1", gesamter_text, perl = TRUE)




# Aufteilen des Textes in Zeilen basierend auf den eingefügten Zeilenumbrüchen
gesplitteter_text <- unlist(strsplit(gesamter_text, "\n"))

#Entfernen Spalte "X1"
gesplitteter_text <- lapply(gesplitteter_text, function(x) {
   sub("^\\\"X1\" \\| \\| ", "", x)
})



# Ersetze | | und \ durch Komma in jedem Datensatz
gesplitteter_text <- lapply(gesplitteter_text, function(x) {
  x <- gsub("\\| \\|", ",", x) # Ersetze | | durch Komma
  gsub("\\\\", ",", x)         # Ersetze \ durch Komma
})

#Macht es möglich .txt als .csv einzulesen 
 txt_to_csv <- paste(gesplitteter_text, collapse = "\n")
 
 #Ab Zeile 491308 wird es eklig, aber lässt sich trotzdem mit arbeiten 
 T34 <- read_csv(txt_to_csv, col_names = TRUE)
 
 return(T34)
  
}
```


###T35 Funktion
```{r}
reading_T35 <- function(data){
  
  gesamter_text <- paste(data, collapse = " ")


# Ersetzen der spezifischen Sequenz durch einen Zeilenumbruch (\n)
# Die Sequenz "\\\"\\d+\"\\\\\\d+\\\\" steht für eine ganze Zahl
# und wird durch einen Zeilenumbruch ersetzt, wobei wir die Sequenz selbst entfernen.
# Fügen \n vor der Sequenz ein, um den neuen Datensatz in einer neuen Zeile zu beginnen.
gesamter_text <- gsub("(?<!^)(\\\"\\d+-\\d+-\\d+-\\d+\"\\\\)", "\n\\1", gesamter_text, perl = TRUE)



# Aufteilen des Textes in Zeilen basierend auf den eingefügten Zeilenumbrüchen
gesplitteter_text <- unlist(strsplit(gesamter_text, "\n"))

#Entfernen Spalte "X1"
 gesplitteter_text <- lapply(gesplitteter_text, function(x) {
   sub("^\\\"X1\"\\\\", "", x)
 })


# Ersetze | | und \ durch Komma in jedem Datensatz
gesplitteter_text <- lapply(gesplitteter_text, function(x) {
  x <- gsub("\\| \\|", ",", x) # Ersetze | | durch Komma
  gsub("\\\\", ",", x)         # Ersetze \ durch Komma
})

#Macht es möglich .txt als .csv einzulesen 
 txt_to_csv <- paste(gesplitteter_text, collapse = "\n")
 
 #Ab Zeile 491308 wird es eklig, aber lässt sich trotzdem mit arbeiten 
 T35 <- read_csv(txt_to_csv, col_names = TRUE)
 
 return(T35)
  
}
```
