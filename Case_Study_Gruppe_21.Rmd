---
title: "Case Study Gruppe 21"
author: Fabian Christian Brak, Malik Dogan, Valentin Benjamin Jimenez Anders, Julius
  Kiso, Theo Grothey
date: "2024-03-17"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Laden von nötigen Paketen 

Zunächst werden die nötigen Packages installiert und geladen, falls nicht bereits vorhanden:

```{r, echo=FALSE}
suppressWarnings({

if(!require(tidyverse)){
  install.packages("tidyverse")
}
library(tidyverse)
})
```

#Vorbereitung
Hier werden einige Vorbereitungen getroffen, um das einlesen zu vereinfachen. In *our_csv* ist schon festgelegt, welche CSV-Dateien für uns relevant sind, damit die Schleife direkt nach diesen suchen kann. Das gleiche für *our_txt*.
Eine Liste, in der die Dateien abgespeichert werden, wird ebenso initialisiert. 

```{r}
folder_path <- "./Data"

#Vektor, wo die für uns relevanten Einzelteile aufgelistet sind 
our_txt <- c("Einzelteil_T31.txt","Einzelteil_T36.txt","Einzelteil_T39.txt")
our_special_txt <- c("Einzelteil_T34.txt","Einzelteil_T35.txt")

our_csv <- c("Einzelteil_T30.csv","Einzelteil_T32.csv","Einzelteil_T33.csv","Einzelteil_T37.csv","Einzelteil_T38.csv","Einzelteil_T40.csv")

col_names_v1 <- c("","X1", "ID_T39.x", "Produktionsdatum.x", "Herstellernummer.x", "Werksnummer.x", 
               "Fehlerhaft.x", "Fehlerhaft_Datum.x", "Fehlerhaft_Fahrleistung.x", 
               "ID_T39.y", "Produktionsdatum.y", "Herstellernummer.y", "Werksnummer.y", 
               "Fehlerhaft.y", "Fehlerhaft_Datum.y", "Fehlerhaft_Fahrleistung.y")

col_names_v2 <- c( "","X1","ID_T36",  "Herstellernummer",  "Werksnummer",  "Fehlerhaft",  "Fehlerhaft_Datum" , "Fehlerhaft_Fahrleistung",  "Produktionsdatum_Origin_01011970",  "origin")

col_names_v3 <- c( "","X1","ID_T31",  "Herstellernummer",  "Werksnummer",  "Fehlerhaft",  "Fehlerhaft_Datum" , "Fehlerhaft_Fahrleistung",  "Produktionsdatum_Origin_01011970",  "origin")


#Dateien mit Semikolon als Seperator
semiko_sep <- c("Einzelteil_T32.csv","Einzelteil_T40.csv")


#Erzeugung leere Liste für die Einzelteile
list_of_parts <- list()


```

## Funktionen zum einlesen von T34 und T35
Diese beiden Dateien stellten eine besondere Herausforderung dar, da diese keinen eindeutigen Zeilenumbruch hatten. Hier musste also ein Muster identifiziert werden, vor welches jeweils ein Zeilenumbruch eingefügt werden sollte.

### T34 Funktion
Ersetzen der spezifischen Sequenz durch einen Zeilenumbruch (\n)
Die Sequenz "\\\"\\d+\"\\\\\\d+\\\\" steht für eine ganze Zahl und wird durch einen Zeilenumbruch ersetzt, wobei wir die Sequenz selbst entfernen. Fügen \n vor der Sequenz ein, um den neuen Datensatz in einer neuen Zeile zu beginnen.

```{r}
reading_T34 <- function(data){
  
  gesamter_text <- paste(data, collapse = " ")

gesamter_text <- gsub("(?<!^)(\"\\d+-\\d+-\\d+-\\d+\" \\| \\| )", "\n\\1", gesamter_text, perl = TRUE)

# Aufteilen des Textes in Zeilen basierend auf den eingefügten Zeilenumbrüchen
gesplitteter_text <- unlist(strsplit(gesamter_text, "\n"))

#Entfernen Spalte "X1"
gesplitteter_text <- lapply(gesplitteter_text, function(x) {
   sub("^\\\"X1\" \\| \\| ", "", x)
})

# Ersetze | | und \ durch Komma in jedem Datensatz
gesplitteter_text <- lapply(gesplitteter_text, function(x) {
  x <- gsub("\\| \\|", ",", x) # Ersetze | | durch Komma
  gsub("\\\\", ",", x)         # Ersetze \ durch Komma
})

 txt_to_csv <- paste(gesplitteter_text, collapse = "\n")
 T34 <- read_csv(txt_to_csv, col_names = TRUE)
 
 return(T34)
}
```

###T35 Funktion
Ersetzen der spezifischen Sequenz durch einen Zeilenumbruch (\n)
Die Sequenz "\\\"\\d+\"\\\\\\d+\\\\" steht für eine ganze Zahl und wird durch einen Zeilenumbruch ersetzt, wobei wir die Sequenz selbst entfernen. Fügen \n vor der Sequenz ein, um den neuen Datensatz in einer neuen Zeile zu beginnen.
```{r}
reading_T35 <- function(data){
  
  gesamter_text <- paste(data, collapse = " ")

gesamter_text <- gsub("(?<!^)(\\\"\\d+-\\d+-\\d+-\\d+\"\\\\)", "\n\\1", gesamter_text, perl = TRUE)



# Aufteilen des Textes in Zeilen basierend auf den eingefügten Zeilenumbrüchen
gesplitteter_text <- unlist(strsplit(gesamter_text, "\n"))

#Entfernen Spalte "X1"
 gesplitteter_text <- lapply(gesplitteter_text, function(x) {
   sub("^\\\"X1\"\\\\", "", x)
 })


# Ersetze | | und \ durch Komma in jedem Datensatz
gesplitteter_text <- lapply(gesplitteter_text, function(x) {
  x <- gsub("\\| \\|", ",", x) # Ersetze | | durch Komma
  gsub("\\\\", ",", x)         # Ersetze \ durch Komma
})

 txt_to_csv <- paste(gesplitteter_text, collapse = "\n")
 
 T35 <- read_csv(txt_to_csv, col_names = TRUE)
 
 return(T35)
}
```

#Einlesen der untersuchten Dateien

CSV- und TXT-Dateien werden gesondert eingelesen, da sich letztere als komplizierter erwiesen haben. 

##Einlesen der CSV-Dateien und speichern in der Liste "list_of_parts"
Der folgende Code durchläuft alle Dateien in unserem Datenordner. Wenn eine Datei geprüft wird, die nicht Teil unserer Suchgruppe ist, wird eine entsprechende Meldung erzeugt. Es unterscheidet auch zwischen Separator ";" und ",". 

```{r}

#Erstellung Vektor mit Dokumentennamen 
file_list_csv <- list.files(folder_path,pattern="*.csv")

for(file in file_list_csv){
  
  full_path <- paste0(folder_path, "/", file)
  
  if(file %in% our_csv){
    
  
    if(file.exists(full_path)){
      if(file %in% semiko_sep){
        
        #read_csv2 zum einlesen mit Semikolon-Trennzeichen 
        list_of_parts[[file]] <- read_csv2(full_path)
        
      }else{
        
        #read_csv zum einlesen mit Komma-Trennzeichen 
        list_of_parts[[file]] <- read_csv(full_path) 
        }
    }
    }else{ 
    
      print(paste(file,"gehört nicht zu den untersuchten .csv Daten"))
      next
    }
  }
  
```

##Einlesen der TXT-Dateien

Die .txt Dateien auf Einzelteilebene hatten mehrere Fehler die ür das einlesen korrigiert werden mussten. Bei Einzeilteil_T31.txt musste man zuerst die Separatoren zu einem lesbaren Format wechseln. Dafür wurde die Funktion str_replace_all() genutzt. T31 hatte auch spezielle Charaktere () die speziell behandelt wurden mit einem erneuten str_replace_all().

```{r warning=FALSE}

#Erstellung Vektor mit Dokumentennamen 
file_list_txt <- list.files(folder_path,pattern="*.txt")

for(file in file_list_txt){
  
   full_path <- paste0(folder_path, "/", file)
   
    if(file == "Einzelteil_T31.txt"){
      data <- readLines(full_path)
      
      #Ersetze Seperatoren und füge Zeilenumbruch ein 
      data <- str_replace_all(data, pattern = "  ", replacement = ";")
      data <- str_replace_all(data, pattern = "", replacement = "\n")
      
      #Füge Datei der Liste hinzu 
      list_of_parts[[file]] <- read.table(text = data, sep = ";", header = FALSE, skip = 1, stringsAsFactors = FALSE, col.names = col_names_v3)
      
    }
    else if(file == "Einzelteil_T36.txt"){
      data <- readLines(full_path)
      data <- str_replace_all(data, pattern = "  ", replacement = ";")
      data <- str_replace_all(data, pattern = " ", replacement = "\n")
      
      list_of_parts[[file]] <- read.table(text = data, sep = ";", header = FALSE, skip = 1, stringsAsFactors = FALSE,col.names = col_names_v2)
    }
    else if(file == "Einzelteil_T34.txt"){
      data <- readLines(full_path)
      
      list_of_parts[[file]] <- reading_T34(data)
      
    }
    else if(file == "Einzelteil_T35.txt"){
      data <- readLines(full_path)

      list_of_parts[[file]] <- reading_T35(data)
      
    }
    else if(file == "Einzelteil_T39.txt"){
      data <- readLines(full_path)
      data <- str_replace_all(data, pattern = fixed("\\"), replacement = ";")
      data <- str_replace_all(data, pattern = " ", replacement = "\n")
      #T39 setzt statt \n erstmal \a aus unerklärlichen Gründen, weshalb \a nochmal ersetzt werden muss 
      data <- str_replace_all(data, pattern = "\a", replacement = "\n")
      
      list_of_parts[[file]] <- read.table(text = data, sep = ";", header = FALSE, skip = 1, stringsAsFactors = FALSE, col.names = col_names_v1)
    
   }else{ 
    
      print(paste(file,"gehört nicht zu den untersuchten .txt Daten"))
      next
    }
  
}

#Sortieren der Liste nach Namen 
list_of_parts <- list_of_parts[order(names(list_of_parts))]

```

# Aufbereitung der Dateien 

Das einlesen erforderte Aktionen, die dazu führten, dass die Daten zusätzlich zu ihrem standardmäßigen Durcheinander. In dieser Sektion sollen alle Fehler korrigiert werden und die Daten standardisiert werden. 

## Funktionen für die Säuberung 

Die Hauptfunktion cleaner_einzeltiel dient zur Säuberung und vereinheitlichung der einzelnen Einzelteil-Datensätze. Die Funktion unterscheidet zu welcher Subfunktion die Einzelteile zugeteilt werden müssen zur Säuberung. 

```{r}

cleaner_einzelteile <- function(Einzelteil){
  
  #Speichern des Inhalts 
  data <- list_of_parts[[Einzelteil]]
  
  if(Einzelteil %in% clean_T34_T35){
    
    clean_data <- cleaning_T34_T35(Einzelteil, data)
     
     clean_data <- adjust_classes(clean_data)
    
    return(clean_data)
  }
  
  else{

    #Löschen der ersten beiden Spalten
    data <- data[,-c(1,2)]
    
    #Reparieren der Spaltennamen 
    clean_data <- cleaning_other(data)
    
    if(Einzelteil %in% Gruppe1){
    
     #Entfernt Spalten so, dass am Ende nur noch Fehlerhafte Teile übrig bleiben    
      clean_data <- clean_data[!is.na(clean_data$Fehlerhaft_Datum),]
      clean_data <- clean_data[!is.na(clean_data[1]),]
     
     clean_data <- clean_data %>%
       rename(Produktionsdatum = Produktionsdatum_Origin_01011970,) %>%
        select(names(clean_data[1]), Produktionsdatum, everything())
     
     clean_data$Produktionsdatum <- as.Date(clean_data$Produktionsdatum, origin="1970-01-01")
     clean_data$origin <- NULL 
     
     clean_data <- adjust_classes(clean_data)
      
      return(clean_data)
      
    }else if(Einzelteil %in% Gruppe2){
      
      #Entfernt Spalten so, dass am Ende nur noch Fehlerhafte Teile übrig bleiben
      clean_data <- clean_data[!is.na(clean_data$Fehlerhaft_Datum),]
      clean_data <- clean_data[!is.na(clean_data[1]),]
      clean_data <- adjust_classes(clean_data)
      
      return(clean_data)
      
    }
  }
}


```

### Säuberungsfunktion für generische Einzelteile

Folgende Funktion, cleaning_other(), dient zur Säuberung aller Einzelteile bis auf T34 und T35, welche eine separate Funktion haben. Diese Funktion ist eingebaut in der Hauptfunktion cleaner_einzelteile().

```{r}

cleaning_other <- function(data){
  
  if (ncol(data) == 7) {
    
      column_vector <- colnames(data)
      column_vector <- na.omit(column_vector)
      
      return(data)
    }
    else if (ncol(data) == 8) {
      
      column_vector <- colnames(data)
      column_vector <- na.omit(column_vector)
      
      return(data)
    }
    else if (ncol(data) == 14) {
      
      original_columns <- colnames(data)[1:7]
      # Löschen des ".x" suffixes in den Spaltennamen
      original_columns <- sub("\\.x$", "", original_columns)
      concatenated_data <- data.frame(matrix(nrow = 2 * nrow(data), ncol = length(original_columns)))
      colnames(concatenated_data) <- original_columns
      
      for (col in original_columns) {
        concatenated_data[[col]] <- c(data[[paste0(col, ".x")]], data[[paste0(col, ".y")]])
      }
      
      return(concatenated_data)
      
    }
    else if (ncol(data) == 21){
      original_columns <- colnames(data)[!grepl("\\.x$|\\.y$", colnames(data))]
      concatenated_data <- data.frame(matrix(nrow = 3 * nrow(data), ncol = length(original_columns)))
      colnames(concatenated_data) <- original_columns
      for (col in original_columns) {
        concatenated_data[[col]] <- c(data[[col]], data[[paste0(col, ".x")]], data[[paste0(col, ".y")]])
      }
      
      return(concatenated_data)
      
    }
}

```

###Säuberungsfunktion von T34 und T35

Spaltennamen umbennen, hier wird Spalte 9, die 1 heißt umbenannt zu "Unsinn", da man diese sonst nicht einfach löschen könnte. Verschieben der Spalte "Produktionsdatum" auf zweite Position.

```{r}
cleaning_T34_T35 <- function(Einzelteil,data){
  
  if(Einzelteil == "Einzelteil_T34.txt"){
    
  T34 <- data 
    
  T34_clean <- T34 %>% 
     rename(Produktionsdatum = Produktionsdatum_Origin_01011970,
            Unsinn = 9) %>%
      select(ID_T34, Produktionsdatum, everything())

  #Spalte in Datumformat bringen - besprechen, ob origin-Spalte genutzt werden muss
  T34_clean$Produktionsdatum <- as.Date(T34_clean$Produktionsdatum, origin = "1970-01-01")
  
  #Restliche Spalten löschen
  T34_clean$...10 <- NULL
  T34_clean$Unsinn <- NULL 
  T34_clean$`origin"1`<- NULL 
  
  #Entfernt alle Zeilen, die nicht Fehlerhafte Bauteile enthalten 
  T34_clean <- T34_clean[!is.na(T34_clean$Fehlerhaft_Datum),]
  T34_clean <- T34_clean[!is.na(T34_clean$ID_T34),]
    
  return(T34_clean)
    
  }else if(Einzelteil == "Einzelteil_T35.txt"){
    
    T35_clean <- data

    #entfernt in der Spalte den "Zahl" character an einigen Dezimalzahlen 
    T35_clean$Fehlerhaft_Fahrleistung.x <- str_replace_all(T35_clean$Fehlerhaft_Fahrleistung.x, '\"[0-9]+\"', '')
   
    #Umbennenung der Spalten 
    T35_clean <- T35_clean %>% 
       rename(ID_T35 = ID_T35.x,
              Produktionsdatum = Produktionsdatum.x,
              Herstellernummer = Herstellernummer.x,
              Werksnummer = Werksnummer.x,
              Fehlerhaft = Fehlerhaft.x,
              Fehlerhaft_Datum = Fehlerhaft_Datum.x,
              Fehlerhaft_Fahrleistung = Fehlerhaft_Fahrleistung.x)
     
    
    T35_clean <- T35_clean %>%
      select(names(T35_clean)[1:7])
    
    T35_clean <- T35_clean[!is.na(T35_clean$ID_T35),]
    T35_clean <- T35_clean[!is.na(T35_clean$Fehlerhaft_Datum),]
    
    return(T35_clean)
    
  }else{
    
    print("Datei gehört nicht zu T34 oder T35 und muss somit anders gesäubert werden!")  
    
    }
}
  
```

### Säuberungsfunktion der Komponentenebene

```{r}
cleaner <- function(data) {
    data$X <- NULL
    data$X.1 <- NULL
    data$X.2 <- NULL
    data$X.3 <- NULL
    data$X.4 <- NULL
    data$X.5 <- NULL
    data$X.6 <- NULL
    data$X.7 <- NULL
    data$X.8 <- NULL
    data$X.9 <- NULL
    data$X.10 <- NULL
    data$X.11 <- NULL
    data$X.12 <- NULL
    data$...1 <- NULL
    
    if (ncol(data) == 8) {
      column_vector <- colnames(data)
      column_vector <- na.omit(column_vector)
      return(data)
    }
    else if (ncol(data) == 14) {
      original_columns <- colnames(data)[1:7]
      # Remove the ".x" suffix from each column name
      original_columns <- sub("\\.x$", "", original_columns)
      concatenated_data <- data.frame(matrix(nrow = 2 * nrow(data), ncol = length(original_columns)))
      colnames(concatenated_data) <- original_columns
      for (col in original_columns) {
        concatenated_data[[col]] <- c(data[[paste0(col, ".x")]], data[[paste0(col, ".y")]])
      }
      return(concatenated_data)
    }
    else {
      return(data)
    }
}

```

