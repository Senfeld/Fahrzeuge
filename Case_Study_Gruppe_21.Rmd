---
title: "Case Study Gruppe 21"
author: Fabian Christian Brak, Malik Dogan, Valentin Benjamin Jimenez Anders, Julius
  Kiso, Theo Grothey
date: "2024-03-17"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

# Vorbereitung
Notwendiger Code um später die RMarkdowndatei in HTML knitten zu können. 
```{r setup, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Laden von nötigen Paketen 

Zunächst werden die nötigen Packages installiert und geladen, falls nicht bereits vorhanden:

```{r, message=FALSE, warning=FALSE}
suppressWarnings({

if(!require(tidyverse)){
  install.packages("tidyverse")
}
library(tidyverse)
})
```

# Vorbereitung
Hier werden einige Vorbereitungen getroffen, um das einlesen zu vereinfachen. In *our_csv* ist schon festgelegt, welche CSV-Dateien für uns relevant sind, damit die Schleife direkt nach diesen suchen kann. Das gleiche für *our_txt*.
Eine Liste, in der die Dateien abgespeichert werden, wird ebenso initialisiert. 

```{r}
folder_path <- "./Data"

# Vektor, wo die für uns relevanten Einzelteile aufgelistet sind 
our_txt <- c("Einzelteil_T31.txt","Einzelteil_T36.txt","Einzelteil_T39.txt")
our_special_txt <- c("Einzelteil_T34.txt","Einzelteil_T35.txt")

our_csv <- c("Einzelteil_T30.csv","Einzelteil_T32.csv","Einzelteil_T33.csv","Einzelteil_T37.csv","Einzelteil_T38.csv","Einzelteil_T40.csv")

col_names_v1 <- c("","X1", "ID_T39.x", "Produktionsdatum.x", "Herstellernummer.x", "Werksnummer.x", 
               "Fehlerhaft.x", "Fehlerhaft_Datum.x", "Fehlerhaft_Fahrleistung.x", 
               "ID_T39.y", "Produktionsdatum.y", "Herstellernummer.y", "Werksnummer.y", 
               "Fehlerhaft.y", "Fehlerhaft_Datum.y", "Fehlerhaft_Fahrleistung.y")

col_names_v2 <- c( "","X1","ID_T36",  "Herstellernummer",  "Werksnummer",  "Fehlerhaft",  "Fehlerhaft_Datum" , "Fehlerhaft_Fahrleistung",  "Produktionsdatum_Origin_01011970",  "origin")

col_names_v3 <- c( "","X1","ID_T31",  "Herstellernummer",  "Werksnummer",  "Fehlerhaft",  "Fehlerhaft_Datum" , "Fehlerhaft_Fahrleistung",  "Produktionsdatum_Origin_01011970",  "origin")


# Dateien mit Semikolon als Separator
semiko_sep <- c("Einzelteil_T32.csv","Einzelteil_T40.csv")


# Erzeugung leere Liste für die Einzelteile
list_of_parts <- list()


```

## Funktionen zum einlesen von T34 und T35
Diese beiden Dateien stellten eine besondere Herausforderung dar. Es war schwierig, beim Einlesen in R festzustellen, wo die Zeilenumbrüche gesetzt werden sollten, da kein klar erkennbares Zeichen vorhanden war. Daher musste ein spezifisches Muster identifiziert werden, um die Zeilenumbrüche entsprechend einzufügen. Zudem wurden weitere Muster identifizeirt, um unnötige Spalten zu entfernen. 
Das ersetzen der Zeichenketten führte jedoch in der Datei zu Fehlern, die nochmal seperat angegangen werden mussten und in der späteren Aufbereitung der Daten behoben wurden. Anschließend wurden die ursprünglichen Separatoren durch "," ersetzt, um sie anschließend als CSV wieder einlesen zu können, da CSV-Dateien eine einfache und klare Struktur besitzen. 


**T34 Funktion**

```{r}
reading_T34 <- function(data){
  
  gesamter_text <- paste(data, collapse = " ")
  
# Einfügen der Zeilenumbrüche 
gesamter_text <- gsub("(?<!^)(\"\\d+-\\d+-\\d+-\\d+\" \\| \\| )", "\n\\1", gesamter_text, perl = TRUE)

# Aufteilen des Textes in Zeilen basierend auf den eingefügten Zeilenumbrüchen
gesplitteter_text <- unlist(strsplit(gesamter_text, "\n"))

#Entfernen Spalte "X1"
gesplitteter_text <- lapply(gesplitteter_text, function(x) {
   sub("^\\\"X1\" \\| \\| ", "", x)
})

# Ersetze | | und \ durch Komma in jedem Datensatz
gesplitteter_text <- lapply(gesplitteter_text, function(x) {
  x <- gsub("\\| \\|", ",", x) # Ersetze | | durch Komma
  gsub("\\\\", ",", x)         # Ersetze \ durch Komma
})

 txt_to_csv <- paste(gesplitteter_text, collapse = "\n")
 T34 <- read_csv(txt_to_csv, col_names = TRUE)
 
 return(T34)
}
```

**T35 Funktion**

```{r}
reading_T35 <- function(data){
  
  gesamter_text <- paste(data, collapse = " ")

gesamter_text <- gsub("(?<!^)(\\\"\\d+-\\d+-\\d+-\\d+\"\\\\)", "\n\\1", gesamter_text, perl = TRUE)



# Aufteilen des Textes in Zeilen basierend auf den eingefügten Zeilenumbrüchen
gesplitteter_text <- unlist(strsplit(gesamter_text, "\n"))

# Entfernen Spalte "X1"
 gesplitteter_text <- lapply(gesplitteter_text, function(x) {
   sub("^\\\"X1\"\\\\", "", x)
 })


# Ersetze | | und \ durch Komma in jedem Datensatz
gesplitteter_text <- lapply(gesplitteter_text, function(x) {
  x <- gsub("\\| \\|", ",", x) # Ersetze | | durch Komma
  gsub("\\\\", ",", x)         # Ersetze \ durch Komma
})

 txt_to_csv <- paste(gesplitteter_text, collapse = "\n")
 
 T35 <- read_csv(txt_to_csv, col_names = TRUE)
 
 return(T35)
}
```

# Einlesen der untersuchten Dateien

CSV- und TXT-Dateien werden gesondert eingelesen, da sich letztere als komplizierter erwiesen haben. 

##Einlesen der Einzelteil CSV-Dateien und speichern in der Liste "list_of_parts"
Der folgende Code durchläuft alle Dateien in unserem Datenordner. Wenn eine Datei geprüft wird, die nicht Teil unserer Suchgruppe ist, wird eine entsprechende Meldung erzeugt. Es unterscheidet auch zwischen Separator ";" und ",". 

```{r, warning=FALSE, message=FALSE}

# Erstellung Vektor mit Dokumentennamen 
file_list_csv <- list.files(folder_path,pattern="*.csv")

for(file in file_list_csv){
  
  full_path <- paste0(folder_path, "/", file)
  
  if(file %in% our_csv){
    
  
    if(file.exists(full_path)){
      if(file %in% semiko_sep){
        
        # read_csv2 zum einlesen mit Semikolon-Trennzeichen 
        list_of_parts[[file]] <- read_csv2(full_path)
        
      }else{
        
        # read_csv zum einlesen mit Komma-Trennzeichen 
        list_of_parts[[file]] <- read_csv(full_path) 
        }
    }
    }else{ 
    
      print(paste(file,"gehört nicht zu den untersuchten .csv Daten"))
      next
    }
  }
  
```

## Einlesen der Einzelteil TXT-Dateien

Die .txt Dateien auf Einzelteilebene hatten mehrere Fehler die ür das einlesen korrigiert werden mussten. Bei Einzeilteil_T31.txt musste man zuerst die Separatoren zu einem lesbaren Format wechseln. Dafür wurde die Funktion str_replace_all() genutzt. T31 hatte auch spezielle Charaktere () die speziell behandelt wurden mit einem erneuten str_replace_all().

```{r, warning=FALSE, message=FALSE}

# Erstellung Vektor mit Dokumentennamen 
file_list_txt <- list.files(folder_path,pattern="*.txt")

for(file in file_list_txt){
  
   full_path <- paste0(folder_path, "/", file)
   
    if(file == "Einzelteil_T31.txt"){
      data <- readLines(full_path)
      
      # Ersetze Separatoren und füge Zeilenumbruch ein 
      data <- str_replace_all(data, pattern = "  ", replacement = ";")
      data <- str_replace_all(data, pattern = "", replacement = "\n")
      
      # Füge Datei der Liste hinzu 
      list_of_parts[[file]] <- read.table(text = data, sep = ";", header = FALSE, skip = 1, stringsAsFactors = FALSE, col.names = col_names_v3)
      
    }
    else if(file == "Einzelteil_T36.txt"){
      data <- readLines(full_path)
      data <- str_replace_all(data, pattern = "  ", replacement = ";")
      data <- str_replace_all(data, pattern = " ", replacement = "\n")
      
      list_of_parts[[file]] <- read.table(text = data, sep = ";", header = FALSE, skip = 1, stringsAsFactors = FALSE,col.names = col_names_v2)
    }
    else if(file == "Einzelteil_T34.txt"){
      data <- readLines(full_path)
      
      list_of_parts[[file]] <- reading_T34(data)
      
    }
    else if(file == "Einzelteil_T35.txt"){
      data <- readLines(full_path)

      list_of_parts[[file]] <- reading_T35(data)
      
    }
    else if(file == "Einzelteil_T39.txt"){
      data <- readLines(full_path)
      data <- str_replace_all(data, pattern = fixed("\\"), replacement = ";")
      data <- str_replace_all(data, pattern = " ", replacement = "\n")
      #T39 setzt statt \n erstmal \a aus unerklärlichen Gründen, weshalb \a nochmal ersetzt werden muss 
      data <- str_replace_all(data, pattern = "\a", replacement = "\n")
      
      list_of_parts[[file]] <- read.table(text = data, sep = ";", header = FALSE, skip = 1, stringsAsFactors = FALSE, col.names = col_names_v1)
    
   }else{ 
    
      print(paste(file,"gehört nicht zu den untersuchten .txt Daten"))
      next
    }
  
}

# Sortieren der Liste nach Namen 
list_of_parts <- list_of_parts[order(names(list_of_parts))]

```

## Einlesen der Komponentendateien

Es wird dasselbe Verfahren wie im vorangegangenen Codeblock angewandt, diesmal jedoch auf der Ebene der Komponenten. 

```{r, warning=FALSE, message=FALSE}

komponenten_li <- c("Komponente_K4.csv", "Komponente_K5.csv", "Komponente_K6.csv", "Komponente_K7.txt")

bestandteilek_li <- c("Bestandteile_Komponente_K4.csv", "Bestandteile_Komponente_K5.csv", "Bestandteile_Komponente_K6.csv", "Bestandteile_Komponente_K7.csv")

col_names <- c("","X1","ID_Karosserie",  "Herstellernummer",  "Werksnummer",  "Fehlerhaft",  "Fehlerhaft_Datum" , "Fehlerhaft_Fahrleistung",  "Produktionsdatum_Origin_01011970",  "origin")

# Erzeugung leere Liste für die Komponenten
list_of_components <- list()
list_of_bestandcomponents <- list()

folder_path <- "./Data"

file_list <- list.files(folder_path)

for(file in file_list){
  
  full_path <- paste0(folder_path, "/", file)
  
  if(file %in% komponenten_li){
    
  
    if(file.exists(full_path)){
      if(file == "Komponente_K7.txt"){
        
        data <- readLines(full_path)
        
        list_of_components[[file]] <- read.table(text = data, sep = "\t", header = FALSE, skip = 1, stringsAsFactors = FALSE, col.names = col_names)
        
      }else if(file=="Komponente_K4.csv" | file=="Komponente_K6.csv"){
        
        # read_csv zum einlesen mit Komma-Trennzeichen 
        list_of_components[[file]] <- read_csv2(full_path) 
      }
      else {
        
        # read_csv zum einlesen mit Komma-Trennzeichen 
        list_of_components[[file]] <- read_csv(full_path) 
      }
    }
  }
  else if(file %in% bestandteilek_li){
    if(file.exists(full_path)){
        list_of_bestandcomponents[[file]] <- read_csv2(full_path) 
      }

 }
}

  
```

## Einlesen der Fahrzeugdateien

```{r, warning=FALSE, message=FALSE}
car_li <- c("Fahrzeuge_OEM1_Typ11.csv", "Fahrzeuge_OEM1_Typ12.csv", "Fahrzeuge_OEM2_Typ21.csv", "Fahrzeuge_OEM2_Typ22.csv")
car_be_li <- c("Bestandteile_Fahrzeuge_OEM1_Typ11.csv", "Bestandteile_Fahrzeuge_OEM1_Typ12.csv", "Bestandteile_Fahrzeuge_OEM2_Typ21.csv", "Bestandteile_Fahrzeuge_OEM2_Typ22.csv")

# Erzeugung leere Liste für die Komponenten
list_of_cars <- list()
list_of_cars_be <- list()

folder_path <- "./Data"

file_list <- list.files(folder_path)

for(file in file_list){
  
  full_path <- paste0(folder_path, "/", file)
  
  if(file %in% car_li){
    
  
    if(file.exists(full_path)){
      if(file=="Fahrzeuge_OEM1_Typ11.csv" | file=="Fahrzeuge_OEM2_Typ21.csv"){
        list_of_cars[[file]] <- read_csv(full_path)
      }
      else if(file=="Fahrzeuge_OEM1_Typ12.csv" | file=="Fahrzeuge_OEM2_Typ22.csv"){
        list_of_cars[[file]] <- read_csv2(full_path)
      }
         
    }
  }
  else if(file %in% car_be_li){
    if(file.exists(full_path)){
      list_of_cars_be[[file]] <- read_csv2(full_path) 
    }
  }
}

  
```

## Einlesen der Geodaten

```{r, warning=FALSE, message=FALSE}

geo_li <- c("Geodaten_Gemeinden_v1.2_2017-08-22_TrR.csv", "Zulassungen_alle_Fahrzeuge.csv")

# Erzeugung leere Liste für die Geodaten
list_of_geo <- list()

folder_path <- "./Data"

file_list <- list.files(folder_path)

for(file in file_list){
  
  full_path <- paste0(folder_path, "/", file)
  
  if(file %in% geo_li){
    if(file.exists(full_path)){
      data <- readLines(full_path)
      
      # Ersetze L„ngengrad mit Laengengrad
      data <- str_replace_all(data, pattern = "L„ngengrad", replacement = "Laengengrad")
      data <- str_replace_all(data, pattern = "L.ngengrad", replacement = "Laengengrad")
      
      # Füge Datei der Liste hinzu 
      list_of_geo[[file]] <- read.table(text = data, sep = ";", header= TRUE)
      }
    }
}

```

## Einlesen der OEM-Werke
Für das Einlesen der OEM-Werke wurden ausschließlich die Tier1 Werke betrachtet, da nur diese für unsere Analyse von Relevanz sind. 

```{r, warning=FALSE, message=FALSE}

OEM_li <- c("OEM_Werke_2017-07-04_TrR.csv")

list_of_OEM <- list()

folder_path <- "./Data"

file_list <- list.files(folder_path)

for(file in file_list){
  
  full_path <- paste0(folder_path, "/", file)
  
  if(file %in% OEM_li){
    if(file.exists(full_path)){
      data <- readLines(full_path)
      
      # Ersetze L„ngengrad mit Laengengrad
      data <- str_replace_all(data, pattern = "L„ngengrad", replacement = "Laengengrad")
      data <- str_replace_all(data, pattern = "L.ngengrad", replacement = "Laengengrad")
      
      # Füge Datei der Liste hinzu 
      list_of_OEM[[file]] <- read.table(text = data, sep = ";", header= TRUE)
      }
    }
}

```

# Datenaufbereitung
Nachdem die Dateien importiert wurden, stellte sich heraus, dass sie keine einheitliche Struktur aufwiesen. Daher war es notwendig, die Dateien zunächst aufzubereiten, bevor mit dem Prozess des Zusammenführens in ein großes tibble begonnen werden konnte. Für diesen Zweck wurden zunächst Funktionen entwickelt, um die Einzelteile, Komponenten und Fahrzeuge zu durchlaufen und sie entsprechend vorzubereiten. 

## Funktionen für die Säuberung 


### Aufbereitung der Einzelteile

Die Funktion _cleaner_einzelteile_ bildet das Herzstück der Aufbereitung der Einzelteile in _list_of_parts_. Sie akzeptiert den Dateinamen aus _list_of_parts_ und unterscheidet je nach Datei, welche Bereinigung durchgeführt werden muss. Es gibt eine Unterscheidung zwischen den Einzelteilen T34/T35 und den übrigen Einzelteilen der Liste, da diese aufgrund von Fehlern, die beim Importieren aufgetreten sind, einer speziellen Aufbereitung bedürfen. Auch zwischen den übrigen Einzelteilen wurde je nach Struktur der Dateien differenziert. Zudem wurden alle **nicht** fehlerhaften Einzelteile entfernt, um Speicher zu sparen sowie die Auswertung zu vereinfachen.  
```{r}

cleaner_einzelteile <- function(Einzelteil){
  
  # Speichern des Inhalts 
  data <- list_of_parts[[Einzelteil]]
  
  if(Einzelteil %in% clean_T34_T35){
    
    clean_data <- cleaning_T34_T35(Einzelteil, data)
    
    clean_data <- adjust_classes(clean_data)
    
    return(clean_data)
  }
  
  else{

    # Löschen der ersten beiden Spalten
    data <- data[,-c(1,2)]
    
    # Restrukturierung der Dateien 
    clean_data <- cleaning_other(data)
    
    if(Einzelteil %in% Gruppe1){
    
     # Entfernt Spalten so, dass am Ende nur noch Fehlerhafte Teile übrig bleiben    
      clean_data <- clean_data[!is.na(clean_data$Fehlerhaft_Datum),]
      clean_data <- clean_data[!is.na(clean_data[1]),]
     
     # Umbenennung von Spalten und weitere Restrukturierung 
     clean_data <- clean_data %>%
       rename(Produktionsdatum = Produktionsdatum_Origin_01011970,) %>%
        select(names(clean_data[1]), Produktionsdatum, everything())
     
     clean_data$Produktionsdatum <- as.Date(clean_data$Produktionsdatum, origin="1970-01-01")
     clean_data$origin <- NULL 
     
     clean_data <- adjust_classes(clean_data)
      
      return(clean_data)
      
    }else if(Einzelteil %in% Gruppe2){
      
      
      clean_data <- clean_data[!is.na(clean_data$Fehlerhaft_Datum),]
      clean_data <- clean_data[!is.na(clean_data[1]),]
      
      clean_data <- adjust_classes(clean_data)
      
      return(clean_data)
      
    }
  }
}

```

#### Restrukturierung der Einzelteile

Die Funktion _cleaning_other_ ist zuständig für die Restrukturierung aller Einzelteile bis auf T34 und T35. Hier wird konkret geschaut, wie viele Spalten vorhanden sind, um die Datei je nachdem anders umzubauen.  

```{r}

cleaning_other <- function(data){
  
  if (ncol(data) == 7) {
    
      column_vector <- colnames(data)
      column_vector <- na.omit(column_vector)
      
      return(data)
    }
    else if (ncol(data) == 8) {
      
      column_vector <- colnames(data)
      column_vector <- na.omit(column_vector)
      
      return(data)
    }
    else if (ncol(data) == 14) {
      
      original_columns <- colnames(data)[1:7]
      # Löschen des ".x" suffixes in den Spaltennamen
      original_columns <- sub("\\.x$", "", original_columns)
      concatenated_data <- data.frame(matrix(nrow = 2 * nrow(data), ncol = length(original_columns)))
      colnames(concatenated_data) <- original_columns
      
      for (col in original_columns) {
        concatenated_data[[col]] <- c(data[[paste0(col, ".x")]], data[[paste0(col, ".y")]])
      }
      
      return(concatenated_data)
      
    }
    else if (ncol(data) == 21){
      original_columns <- colnames(data)[!grepl("\\.x$|\\.y$", colnames(data))]
      concatenated_data <- data.frame(matrix(nrow = 3 * nrow(data), ncol = length(original_columns)))
      colnames(concatenated_data) <- original_columns
      for (col in original_columns) {
        concatenated_data[[col]] <- c(data[[col]], data[[paste0(col, ".x")]], data[[paste0(col, ".y")]])
      }
      
      return(concatenated_data)
      
    }
}

```

####Säuberung der Spezialfälle T34 und T35

Wie bereits erwähnt, sind beim imporiteren der Einzelteile T34 und T35 Fehler entstanden, wodruch diese eine gesonderten Säuberung benötigen.  
Beispielsweise entstand die Spalte _1_ in T34, die nicht einfach aufgerufen werden konnte mit _$_. Deshlab musste diese erstmal umbenannte werden, damit sie entfernt werden konnte. Zudem wurden hier, wie zuvor in den anderen Einzelteilen, NA entfernt.  

```{r}
cleaning_T34_T35 <- function(Einzelteil,data){
  
  if(Einzelteil == "Einzelteil_T34.txt"){
    
  T34 <- data 
    
  T34_clean <- T34 %>% 
     rename(Produktionsdatum = Produktionsdatum_Origin_01011970,
            Unsinn = 9) %>%
      select(ID_T34, Produktionsdatum, everything())

  T34_clean$Produktionsdatum <- as.Date(T34_clean$Produktionsdatum, origin = "1970-01-01")
  
  #R estliche Spalten löschen
  T34_clean$...10 <- NULL
  T34_clean$Unsinn <- NULL 
  T34_clean$`origin"1`<- NULL 
  
  # Entfernt alle Zeilen, die nicht Fehlerhafte Bauteile enthalten 
  T34_clean <- T34_clean[!is.na(T34_clean$Fehlerhaft_Datum),]
  T34_clean <- T34_clean[!is.na(T34_clean$ID_T34),]
    
  return(T34_clean)
    
  }else if(Einzelteil == "Einzelteil_T35.txt"){
    
    T35_clean <- data

    # Entfernt in der Spalte den "Zahl" character an einigen Dezimalzahlen 
    T35_clean$Fehlerhaft_Fahrleistung.x <- str_replace_all(T35_clean$Fehlerhaft_Fahrleistung.x, '\"[0-9]+\"', '')
   
    # Umbenennung der Spalten 
    T35_clean <- T35_clean %>% 
       rename(ID_T35 = ID_T35.x,
              Produktionsdatum = Produktionsdatum.x,
              Herstellernummer = Herstellernummer.x,
              Werksnummer = Werksnummer.x,
              Fehlerhaft = Fehlerhaft.x,
              Fehlerhaft_Datum = Fehlerhaft_Datum.x,
              Fehlerhaft_Fahrleistung = Fehlerhaft_Fahrleistung.x)
     
    
    T35_clean <- T35_clean %>%
      select(names(T35_clean)[1:7])
    
    T35_clean <- T35_clean[!is.na(T35_clean$ID_T35),]
    T35_clean <- T35_clean[!is.na(T35_clean$Fehlerhaft_Datum),]
    
    return(T35_clean)
    
  }else{
    
    print("Datei gehört nicht zu T34 oder T35 und muss somit anders gesäubert werden!")  
    
    }
}
  
```

#### Anpassung der Spaltenklassen 

Diese Funktion passt die Klassen der Spalten im Dataframe an. Sie konvertiert bestimmte Spalten in das Datumsformat, bestimmte Spalten in das Zeichenformat und bestimmte Spalten in das numerische Format. Dies ist notwendig um später die verschiedenen Dataframes zu joinen und Fehler in Berechnungen zu vermeiden.

```{r}

adjust_classes <- function(df) {
  # Anpassung der Klassen 
  df <- df %>%
    mutate(across(c(Produktionsdatum, Fehlerhaft_Datum), as.Date),
           across(names(df[1]), as.character),
           across(c(Herstellernummer, Werksnummer, Fehlerhaft,Fehlerhaft_Fahrleistung), as.numeric))
  return(df)
}

```

### Aufbereitung der Komponenten und Fahrzeuge  

Die Aufbereitung der Komponenten- und Fahrzeugebene erwies sich als einfacher. Wie für die Einzelteile wurde für die Komponenten und Fahrzeuge eine Funktion geschrieben, die die Aufbereitung durchführt. Die Logik für _cleaning_Komponenten_ und _cleaning_cars_ entspricht der von _cleaner_einzelteile_. 


**Aufbereitung der Komponenten** 
```{r}
cleaning_Komponenten <- function(Komponente){
  
  
  data <- list_of_components[[Komponente]]
  clean_component <- cleaner(data)
  if(Komponente %in% Gruppe1_Komponente){
    
    
    
    
    clean_component <- clean_component[!is.na(clean_component$ID_Karosserie), ]
    
    clean_component <- adjust_classes(clean_component)
    
    return(clean_component)
    
  }else if(Komponente %in% Gruppe2_Komponente){
    
    clean_component <- clean_component %>% 
      rename(Produktionsdatum = Produktionsdatum_Origin_01011970,) %>%
        select(names(clean_component[1]), Produktionsdatum, everything())
    
    clean_component$Produktionsdatum <-  as.Date(clean_component$Produktionsdatum, origin = "1970-01-01")
    
    clean_component$origin <- NULL 
    
    
    clean_component <- clean_component[!is.na(clean_component$ID_Karosserie), ]
    
    clean_component <- adjust_classes(clean_component)
    
    return(clean_component)
  }
  
  
}
```


**Aufbereitung der Fahrzeuge** 
```{r}
cleaning_cars <- function(Fahrzeug){
  
  data <- list_of_cars[[Fahrzeug]]
  clean_car <- cleaner(data)
  
  if(Fahrzeug %in% Gruppe1_Autos){

    clean_car <- adjust_classes(clean_car)  

    return(clean_car)

  }else if(Fahrzeug %in% Gruppe2_Autos){

    clean_car <- clean_car %>%
      rename(Produktionsdatum = Produktionsdatum_Origin_01011970,) %>%
        select(names(clean_car[1]), Produktionsdatum, everything())

    clean_car$Produktionsdatum <-  as.Date(clean_car$Produktionsdatum, origin = "1970-01-01")

    clean_car$origin <- NULL

    clean_car <- adjust_classes(clean_car)

    return(clean_car)
  }
}

```

#### Weitere Funktion zur Restrukturierung 

Diese Funktion ist nahezu identisch zur Funktion _cleaning_other_ und verfolgt das selbe Ziel. Man hätte beide zusammenführen können, um eine Funktion für alle Ebenen zu schreiben. 

```{r}
cleaner <- function(data) {
    data$X <- NULL
    data$X1 <- NULL
    data$X.1 <- NULL
    data$X.2 <- NULL
    data$X.3 <- NULL
    data$X.4 <- NULL
    data$X.5 <- NULL
    data$X.6 <- NULL
    data$X.7 <- NULL
    data$X.8 <- NULL
    data$X.9 <- NULL
    data$X.10 <- NULL
    data$X.11 <- NULL
    data$X.12 <- NULL
    data$...1 <- NULL
    
    if (ncol(data) == 8) {
      column_vector <- colnames(data)
      column_vector <- na.omit(column_vector)
      return(data)
    }
    else if (ncol(data) == 14) {
      original_columns <- colnames(data)[1:7]
      # Remove the ".x" suffix from each column name
      original_columns <- sub("\\.x$", "", original_columns)
      concatenated_data <- data.frame(matrix(nrow = 2 * nrow(data), ncol = length(original_columns)))
      colnames(concatenated_data) <- original_columns
      for (col in original_columns) {
        concatenated_data[[col]] <- c(data[[paste0(col, ".x")]], data[[paste0(col, ".y")]])
      }
      return(concatenated_data)
    }
    else {
      return(data)
    }
}

```



## Ausführung der Aufbereitung 

### Einzelteile

Nachdem die Funktionen gelesen wurden, konnte mit der Ausführung der Aufbereitung begonnen werden. Hierfür wurden zunächst Vorbereitungen getroffen, einschließlich der Einteilung der Dateien nach der Art und Weise der Säuberung. Nachdem die Säuberung durchgeführt wurde, wurden die Dateien erneut nach der Herstellernummer 217 gefiltert, da diese für unsere Analyse von Bedeutung ist. Abschließend wurden den Spaltennamen jedes Einzelteils die Nummer des Einzelteils angefügt, um später beim Zusammenführen aller Dateien Dopplungen in den Spaltennamen zu vermeiden. 

```{r}

list_of_parts_clean <- list()
n <- 30 

# Gruppierung nach benötigter Säuberung 
clean_T34_T35 <- c("Einzelteil_T34.txt", "Einzelteil_T35.txt")

# Gruppe1 sind die Dateien mit 10 == Spalten 
Gruppe1 <- c("Einzelteil_T31.txt","Einzelteil_T33.csv","Einzelteil_T36.txt","Einzelteil_T37.csv","Einzelteil_T40.csv")

# Gruppe1 sind die Dateien mit 16 <= Spalten
Gruppe2 <- c("Einzelteil_T30.csv","Einzelteil_T32.csv","Einzelteil_T38.csv","Einzelteil_T39.txt")

cols <- c("Produktionsdatum","Herstellernummer", "Werksnummer","Fehlerhaft","Fehlerhaft_Datum","Fehlerhaft_Fahrleistung")

# Ausführung Säuberung 
list_of_parts_clean <- setNames(
  lapply(names(list_of_parts), function(Einzelteil) {
      cleaner_einzelteile(Einzelteil)
  }),
  names(list_of_parts)
)
# Filterung nach Herstellernummer 217
list_of_parts_clean <- lapply(list_of_parts_clean, function(df) {
                          filter(df, Herstellernummer == 217)
                        })
  
list_of_parts_clean <- Filter(function(x) nrow(x) > 0, list_of_parts_clean)

# Hinzufügen der Einzelteilnummer zu jeder Spalte des Einzelteils 
for (Einzelteil in names(list_of_parts_clean)) { 
  
  list_of_parts_clean[[Einzelteil]] <- list_of_parts_clean[[Einzelteil]] %>% 
    rename_with(
        ~ paste0(., "_T", n), 
        .cols = all_of(cols))

  n <- n+1
}

```

### Komponenten 

Das gleiche Verfahren wie bei den Einzelteilen wird nun auf der Ebene der Komponenten angewandt. Zusätzlich zu den Komponenten und Fahrzeugen gibt es auch Dateien mit der Bezeichnung "Bestandteile" auf der Komponenten- und Fahrzeugebene. Diese Dateien werden später verwendet, um die verschiedenen Ebenen miteinander zu verbinden.

```{r}
Gruppe1_Komponente <- c("Komponente_K4.csv","Komponente_K5.csv")
Gruppe2_Komponente <- c("Komponente_K6.csv","Komponente_K7.txt")

list_of_components_clean <- list()
for(Komponente in names(list_of_components)){
  
  list_of_components_clean[[Komponente]] <- cleaning_Komponenten(Komponente)
  
}

#Säuberung der Bestandteile
cleandata <- cleaner(list_of_bestandcomponents$Bestandteile_Komponente_K4.csv)
K4_Best <- cleandata[!is.na(cleandata$ID_K4), ]
K4_Best <- K4_Best %>%
  rename(ID_Komponente = ID_K4)
  
cleandata <- cleaner(list_of_bestandcomponents$Bestandteile_Komponente_K5.csv)
K5_Best <- cleandata[!is.na(cleandata$ID_K5), ]
K5_Best <- K5_Best %>%
  rename(ID_Komponente = ID_K5)

cleandata <- cleaner(list_of_bestandcomponents$Bestandteile_Komponente_K6.csv)
K6_Best <- cleandata[!is.na(cleandata$ID_K6), ]
K6_Best <- K6_Best %>%
  rename(ID_Komponente = ID_K6)

cleandata <- cleaner(list_of_bestandcomponents$Bestandteile_Komponente_K7.csv)
K7_Best <- cleandata[!is.na(cleandata$ID_K7), ]
K7_Best <- K7_Best %>%
  rename(ID_Komponente = ID_K7)

```

### Fahrzeuge

```{r, message=FALSE, warning=FALSE}
list_of_cars_clean <- list()

Gruppe1_Autos <- c("Fahrzeuge_OEM1_Typ11.csv","Fahrzeuge_OEM1_Typ12.csv")
Gruppe2_Autos <- c("Fahrzeuge_OEM2_Typ21.csv","Fahrzeuge_OEM2_Typ22.csv")


for(Fahrzeug in names(list_of_cars)){
  
  list_of_cars_clean[[Fahrzeug]] <- cleaning_cars(Fahrzeug)
  
}

#Säuberung Bestandteile Fahrzeuge

cleandata <- cleaner(list_of_cars_be$Bestandteile_Fahrzeuge_OEM1_Typ11.csv)
cleandata <- cleandata[,c(1,5)]
B_OEM1_11 <- cleandata[!is.na(cleandata$ID_Fahrzeug), ]

cleandata <-cleaner(list_of_cars_be$Bestandteile_Fahrzeuge_OEM1_Typ12.csv)
cleandata <- cleandata[,c(1,5)]
B_OEM1_12 <- cleandata[!is.na(cleandata$ID_Fahrzeug), ]

cleandata <- cleaner(list_of_cars_be$Bestandteile_Fahrzeuge_OEM2_Typ21.csv)
cleandata <- cleandata[,c(1,5)]
B_OEM2_21 <- cleandata[!is.na(cleandata$ID_Fahrzeug), ]

cleandata <- cleaner(list_of_cars_be$Bestandteile_Fahrzeuge_OEM2_Typ22.csv)
cleandata <- cleandata[,c(1,5)]
B_OEM2_22 <- cleandata[!is.na(cleandata$ID_Fahrzeug), ]

```

### OEM Werke
Die OEM_Werke Datei wurde mit der Standard-Funktion, cleaner(), gesäubert. Nach Prüfung des "sauberen" Dataframes, wurde festgestellt, dass die Spalte "Werk" ein "O" vor den Zahlen enthielt. Um dieses zu entfernen, wurde eine gsub-Funktion verwendet. Schließlich wurden die Spalten umbenannt, um die Unterscheidung mit anderen Spalten in der verbundenen Datenbank zu erleichtern. 
```{r}
cleandata <- cleaner(list_of_OEM$"OEM_Werke_2017-07-04_TrR.csv")

OEMs <- cleandata[!is.na(cleandata$ORT), ]
OEMs$Werk <- sub("^O", "", OEMs$Werk)

OEMs <- OEMs %>%
  rename(OEM_Breitengrad = Breitengrad) %>%
  rename(OEM_Laengengrad = Laengengrad) %>%
  rename(OEM_Ort = ORT) %>%
  mutate(Werk = as.numeric(Werk)) %>%
  rename(Fahrzeug_Werksnummer = Werk) %>%
  rename(OEM_Postleitzahl = PLZ)

```

### Geodaten 

```{r}
cleandata <- cleaner(list_of_geo$"Geodaten_Gemeinden_v1.2_2017-08-22_TrR.csv")
Gemeinden <- cleandata[!is.na(cleandata$Postleitzahl), ]

cleandata <- cleaner(list_of_geo$"Zulassungen_alle_Fahrzeuge.csv")
Zulassungen <- cleandata[!is.na(cleandata$IDNummer), ]
  
Zulassungen <- Zulassungen %>%
  rename(ID_Fahrzeug = IDNummer) %>%
  rename(Gemeinde = Gemeinden)
```

# Erstellen des finalen Datensatzes 

## Komponenten, Fahrzeuge und Bestandteile

Für die Komponenten, die Fahrzeuge und die jeweiligen Bestandteile läuft das Zusammenführen nahezu identisch ab. Es wird zuerst ein _full_join_ genutzt, um am Ende ein tibble zu erhalten, welches beispielsweise alle Komponenten beinhaltet. 

### Komponenten 

```{r, message=FALSE, warning=FALSE}  

Komponenten_full <- tibble(
  ID_Karosserie = character(),
  Produktionsdatum = as.Date(NA),
  Herstellernummer = numeric(),
  Werksnummer = numeric(),
  Fehlerhaft = numeric(),
  Fehlerhaft_Datum = as.Date(NA),
  Fehlerhaft_Fahrleistung = numeric()
)

for(Komponente in names(list_of_components_clean)){
  
  Komponenten_full <- full_join(Komponenten_full,list_of_components_clean[[Komponente]])
  
}

#Umbennenung der Spalten 
Komponenten_full <- Komponenten_full %>%
  rename(ID_Komponente = ID_Karosserie,
         Komponente_Produktionsdatum = Produktionsdatum,
         Komponente_Fehlerhaft_Datum = Fehlerhaft_Datum,
         Komponente_Werksnummer = Werksnummer,
         Komponente_Fehlerhaft = Fehlerhaft,
         Komponente_Herstellernummer = Herstellernummer,
         Komponente_Fehlerhaft_Fahrleistung = Fehlerhaft_Fahrleistung)
 
#Joining der Bestandteile zu einem großen tibble
Komponenten_full_be <- full_join(K4_Best,K5_Best)
Komponenten_full_be <- full_join(Komponenten_full_be,K6_Best)
Komponenten_full_be <- full_join(Komponenten_full_be,K7_Best)

```

### Fahrzeuge

```{r, message=FALSE, warning=FALSE}  

Fahrzeuge_full <- tibble(
  ID_Fahrzeug = character(),
  Produktionsdatum = as.Date(NA),
  Herstellernummer = numeric(),
  Werksnummer = numeric(),
  Fehlerhaft = numeric(),
  Fehlerhaft_Datum = as.Date(NA),
  Fehlerhaft_Fahrleistung = numeric()
)

for(Fahrzeug in names(list_of_cars)){
  
  Fahrzeuge_full <- full_join(Fahrzeuge_full,list_of_cars_clean[[Fahrzeug]])
  
}

Fahrzeuge_full_be <- tibble(
  ID_Karosserie = character(),
  ID_Fahrzeug = character()
)

Fahrzeuge_full_be <- full_join(Fahrzeuge_full_be,B_OEM1_11)
Fahrzeuge_full_be <- full_join(Fahrzeuge_full_be,B_OEM1_12)
Fahrzeuge_full_be <- full_join(Fahrzeuge_full_be,B_OEM2_21)
Fahrzeuge_full_be <- full_join(Fahrzeuge_full_be,B_OEM2_22)
```

## Geodaten und Zulassungen

```{r}  
Zulassungen_Gemeinde <- left_join(Zulassungen, Gemeinden, by="Gemeinde")
```

## Joining der Bestandteile

```{r}

#Fahrzeuge joinen mit Bestandteilen 
Fahrzeuge <- left_join(Fahrzeuge_full_be, Fahrzeuge_full, by="ID_Fahrzeug")

Fahrzeuge <- Fahrzeuge %>%
  select(ID_Fahrzeug,names(Fahrzeuge[3:8]),ID_Karosserie) %>%
  rename(ID_Komponente = ID_Karosserie,
         Fahrzeug_Produktionsdatum = Produktionsdatum,
         Fahrzeug_Fehlerhaft_Datum = Fehlerhaft_Datum,
         Fahrzeug_Werksnummer = Werksnummer,
         Fahrzeug_Fehlerhaft = Fehlerhaft,
         Fahrzeug_Herstellernummer = Herstellernummer,
         Fahrzeug_Fehlerhaft_Fahrleistung = Fehlerhaft_Fahrleistung)

#Komponenten joinen mit Bestandteilen
Komponenten <- left_join(Komponenten_full,Komponenten_full_be,by="ID_Komponente")

```

## Erstellung der Großen Datenbank
Hier werden die tibble zusammengeführt um das die Große Datenbank zu erstellen.
```{r}

 Große_Datenbank <- left_join(Fahrzeuge, OEMs, by="Fahrzeug_Werksnummer")
 Große_Datenbank <- left_join(Große_Datenbank, Komponenten, by="ID_Komponente")

for(Einzelteil in names(list_of_parts_clean)){
  
  Große_Datenbank <- left_join(Große_Datenbank,list_of_parts_clean[[Einzelteil]], by=names(list_of_parts_clean[[Einzelteil]])[1])
}

```

## Erstellung der zweiten großen Datenbank 
Für die Auswertung wurde eine zweite große Datennbank erstellt namens _Große_Datenbank2_, welche ausschließlich fehlerhafte Bauteile beinhaltet. Dies vereinfacht den Umgang, da sie die ursprüngliche Datenbank verkkleinert. 
```{r}

Große_Datenbank2 <- Große_Datenbank[!(is.na(Große_Datenbank$Fahrzeug_Fehlerhaft_Datum) & is.na(Große_Datenbank$Komponente_Fehlerhaft_Datum) & rowSums(is.na(Große_Datenbank[,30:ncol(Große_Datenbank)])) == ncol(Große_Datenbank[,30:ncol(Große_Datenbank)])),]

Große_Datenbank2 <- left_join(Große_Datenbank2, Zulassungen_Gemeinde, by="ID_Fahrzeug")

# Ersetze "," durch "." und konvertiere dann in Numeric
Große_Datenbank2$Laengengrad <- as.numeric(gsub(",", ".", Große_Datenbank2$Laengengrad))
Große_Datenbank2$Breitengrad <- as.numeric(gsub(",", ".", Große_Datenbank2$Breitengrad))

Große_Datenbank2$Laengengrad <- as.numeric(Große_Datenbank2$Laengengrad)
Große_Datenbank2$Breitengrad <- as.numeric(Große_Datenbank2$Breitengrad)

```

# Auswertung der Daten und Vorbereitung für Shiny-App 

## Vorbereitung für die Heatmap 
Zuerst zählen wir, wie oft fehlerhafte Autos in der jeweiligen Gemeinde vorkamen, um aus diesen Informationen die Heatmap zu erstellen. 

```{r}
Gemeinde_Fehler_Häufigkeit <- Große_Datenbank2 %>% 
  group_by(Gemeinde) %>% 
  summarize(Anzahl_Fehler = n(),
            Laengengrad = first(Laengengrad),  
            Breitengrad = first(Breitengrad),
            Postleitzahl = first(Postleitzahl))

Gemeinde_Fehler_Häufigkeit <- na.omit(Gemeinde_Fehler_Häufigkeit)
```

## Laden von benötigten Paketen
```{r, message=FALSE, warning=FALSE}
if(!require(install.load)){
  install.packages("install.load")
}

library(install.load)
install_load("DT","leaflet","leaflet.extras","plotly","tidyverse","shiny","shinythemes")
```

# Shiny-Applikation
## User Interface (UI)
```{r}
ui <- fluidPage(
  titlePanel(title = div(img(src = "autos.png", alt = "Mein Logo", height = "50px"),"Datenanalyse")),
  tags$head(
    tags$style(HTML("
      body {
        background-color: lightsteelblue;
      }

      .navbar {
        background-color: lightsteelblue !important;
      }

      .sidebar {
        background-color: lightsteelblue !important;
      }
    "))
  ),
  tabsetPanel(
    tabPanel("Suche",
      fluidPage(
        titlePanel("Autokarte"),
          tags$style(HTML("
            #search_panel {
              position: absolute;
              top: 180px; /* Anpassen der Position nach Bedarf */
              left: 85px; /* Anpassen der Position nach Bedarf */
              z-index: 1000;
              background-color: lightsteelblue;
              padding: 10px;
              border-radius: 5px;
              border: 3px solid white; /* Rahmen um das Suchfeld */
            }
      
            #map-container {
              border: 3px solid white; /* Rahmen um die Karte */
              border-radius: 5px;
              padding: 0px;
            }
          ")),
            div(
              id = "search_panel",
              textInput("vehicle_id", "Fahrzeug-ID eingeben:"),
              actionButton("search_button", "Suche starten"),
              verbatimTextOutput("vehicle_status")
            ),
            div(
              id = "map-container",
              leafletOutput("map", width = "100%", height = "calc(100vh - 150px)")
            )
      )
    ),
    
    tabPanel("Produktionsmenge",
  fluidPage(
    sidebarLayout(
      sidebarPanel(
        titlePanel("Filter"),
        dateInput("from_date", "Produktionszeitraum von"),
        dateInput("to_date", "Produktionszeitraum bis"),
        selectInput("ebene_dropdown", "Ebene auswählen:", choices = c("Komponente", "Einzelteile")),
        actionButton("Balkendiagramm_generieren", "Erstellen"),
        style = "margin-top: 50px; border: 5px solid white; border-radius: 5px; padding: 10px;" 
      ),
      mainPanel(
        plotlyOutput("histogram"),
        style = "margin-top: 20px; border: 5px solid white; border-radius: 5px; padding: 10px;" 
      )
    )
  )
),

    tabPanel("Daten",
      fluidPage(
        titlePanel("Große Datenbank"),
        DTOutput("daten_tabelle")
      )
    ),
    tabPanel("Nutzungsdauer - Vergleich",
      sidebarLayout(
        sidebarPanel(
          titlePanel("Filter"),
          textInput("zip_code1", "Enter Zip Code 1:"),
          textInput("zip_code2", "Enter Zip Code 2:"),
          actionButton("boxplot_generieren", "Generate Box Plot"),
          style = "margin-top: 20px; border: 5px solid white; border-radius: 5px; padding: 10px;"
        ),
        mainPanel(
          fluidRow(
            column(width = 6, 
              div(class = "boxplot-container", 
                plotlyOutput("boxplot_left", height = "400px")
              )
            ),
            column(width = 6, 
              div(class = "boxplot-container", 
                plotlyOutput("boxplot_right", height = "400px")
              )
            )
          ),
          style = "margin-top: 20px; border: 5px solid white; border-radius: 5px; padding: 10px;"
        )
      )
    )
  )
)

```

## Plots
```{r}
server <- function(input, output, session) {
  
  
  # Karte rendern
  output$map <- renderLeaflet({
    leaflet() %>%
      addTiles() %>%
      addHeatmap(
        data = Gemeinde_Fehler_Häufigkeit,
        lat = ~Breitengrad,
        lng = ~Laengengrad,
        intensity = ~Anzahl_Fehler,
        radius = 10,
        max = 10,
        blur = 20) %>% 
      setView(lng = 10.4515, lat = 51.1657, zoom = 6)
  })
  
  
  
  
  observeEvent(input$Balkendiagramm_generieren, {
   
    
    # Produktionsmenge Histogramm
    # Generate histogram based on filtered data
    filtered_data <- reactive({
      from_date <- isolate(input$from_date)
      to_date <- isolate(input$to_date)
      
      # Filter data based on selected date range
      filtered <- Große_Datenbank %>%
        filter(Fahrzeug_Produktionsdatum >= from_date & Fahrzeug_Produktionsdatum <= to_date) %>%
        mutate(Komponente = substr(ID_Komponente, 1, 2))
      
      return(filtered)
    })
    
    
     output$histogram <- renderPlotly({
    if (isolate(input$ebene_dropdown) == "Komponente") {
      # Plot Balkendiagramm für Komponente
      ggplotly(
      ggplot(filtered_data(), aes(x = OEM_Ort, fill = Komponente)) +
        geom_bar(position = "stack") +
        labs(title = "Produktionsmengen", x = "OEM Werk", y = "Komponentenmengen")
      )
    } else if (isolate(input$ebene_dropdown) == "Einzelteile") {
      
      oem_parts_df <- filtered_data() %>%
        select(OEM_Ort, starts_with("ID_T"))
      
      oem_parts_df$Anzahl_Einzelteile <- rowSums(!is.na(oem_parts_df[,paste0("ID_T",30:40)]))
      
      oem_parts_sum <- aggregate(Anzahl_Einzelteile ~ OEM_Ort, data = oem_parts_df, FUN = sum)

      # Plot Balekndiagramm für Einzelteile
      ggplotly(
      ggplot(oem_parts_sum, aes(x = OEM_Ort, y = Anzahl_Einzelteile)) +
       geom_bar(stat = "identity", fill = "lightsteelblue") +
       labs(title = "Gesamtanzahl der verbauten Einzelteile nach OEM-Ort",
            x = "OEM-Ort",
            y = "Gesamtanzahl der Einzelteile")
      )
      
     }
   })
 })
  
  
  # Tabelle mit den Daten
  ## Filtern und formatieren der Daten
  daten <- reactive({
    Große_Datenbank %>%
      select(ID_Fahrzeug, 
             Fahrzeug_Fehlerhaft_Datum, 
             Fahrzeug_Fehlerhaft_Fahrleistung, 
             ID_Komponente, 
             Komponente_Fehlerhaft_Datum, 
             Komponente_Fehlerhaft_Fahrleistung,
             starts_with("ID_T"),
             starts_with("Fehlerhaft_Datum_T"),
             starts_with("Fehlerhaft_Fahrleistung_T")) %>%
      mutate(across(contains("Datum"), as.Date),
             across(contains("Fahrleistung"), ~ round(., digits = 0)))  # Runden der Fahrleistung auf ganze Zahlen
  })
  
  # Anzeigen der Daten in einer interaktiven Tabelle
  output$daten_tabelle <- renderDT({
    datatable(daten(), 
              options = list(pageLength = 10),  # Anzahl der Zeilen pro Seite
              rownames = FALSE) %>%  # Keine Zeilennummern anzeigen
      formatStyle(names(daten()), background = "white", fontWeight = "bold") # Hintergrundfarbe und Schriftstärke für alle Spalten festlegen

  })
  
  # Fahrzeug-Suche
  observeEvent(input$search_button, {
        req(input$vehicle_id)  # Stelle sicher, dass eine Fahrzeug-ID eingegeben wurde
    
    if(input$vehicle_id %in% Große_Datenbank2$ID_Fahrzeug) {
      # Extrahieren Sie die Informationen zum Fahrzeug
      vehicle_info <- Große_Datenbank2[Große_Datenbank2$ID_Fahrzeug == input$vehicle_id, ]
      fehlerhaft <- paste("Ihr Fahrzeug mit der ID ", input$vehicle_id," ist fehlerhaft!")
      # Bestimme, ob das Fahrzeug, die Komponente oder eines der Einzelteile fehlerhaft ist
      if (!is.na(vehicle_info$Fahrzeug_Fehlerhaft_Datum)) {
        fehler_text <- "Das Fahrzeug ist fehlerhaft."
        fehler_datum <- vehicle_info$Fahrzeug_Fehlerhaft_Datum
        fehler_fahrleistung <- vehicle_info$Fahrzeug_Fehlerhaft_Fahrleistung
      } else if (!is.na(vehicle_info$Komponente_Fehlerhaft_Datum)) {
        fehler_text <- "Eine Komponente des Fahrzeugs ist fehlerhaft."
        fehler_datum <- vehicle_info$Komponente_Fehlerhaft_Datum
        fehler_fahrleistung <- vehicle_info$Komponente_Fehlerhaft_Fahrleistung
      } else {
        # Überprüfe jedes Einzelteil
        fehler_text <- NULL
        for (i in 30:40) {
          column_name <- paste("Fehlerhaft_Datum_T", i, sep = "")
          column_name_leistung <- paste("Fehlerhaft_Fahrleistung_T", i, sep = "")
          if (!is.na(vehicle_info[[column_name]])) {
            fehler_text <- paste("Ein Einzelteil (T", i, ") des Fahrzeugs ist fehlerhaft.", sep = "")
            fehler_datum <- vehicle_info[[column_name]]  
            fehler_fahrleistung <- round(vehicle_info[[column_name_leistung]], digits = 2)
            break
          }
        }
      }
      
      # Erstelle Popup-Nachricht mit den Fahrzeuginformationen und Fehlerstatus
      popup_text <- paste(
        "Herstellernummer - Fahrzeug:", vehicle_info$Fahrzeug_Herstellernummer, "<br>",
        "Produktionsdatum - Fahrzeug:", vehicle_info$Fahrzeug_Produktionsdatum, "<br>",
        "Fehlerhaftes Teil:",fehler_text,"<br>",
        "Datum - Fehler:",fehler_datum,"<br>",
        "Fahrlesitung - Fehler (km):",fehler_fahrleistung
        
      )
      
      # Füge den CircleMarker zur Karte hinzu
      leafletProxy("map", session) %>%
        clearMarkers() %>%
        addCircleMarkers(lng = vehicle_info$Laengengrad, lat = vehicle_info$Breitengrad, radius = 10, 
                         popup = popup_text)
      
      # Gebe die den Fehlerstatus aus
      output$vehicle_status <- renderText({
        paste("Fehlerstatus: ", fehlerhaft)
      })
    } else {
      output$vehicle_status <- renderText({
        "Ihr Fahrzeug ist nicht fehlerhaft."
      })
    }
  })
  
  
  observeEvent(input$boxplot_generieren, {
  zip_code1 <- isolate(input$zip_code1)
  zip_code2 <- isolate(input$zip_code2)
  
  # Filter data for the entered zip codes
  Große_Datenbank2$Postleitzahl <- as.character(Große_Datenbank2$Postleitzahl)
  
  PLZ1 <- Große_Datenbank2 %>% 
    filter(Postleitzahl == zip_code1 & Komponente_Fehlerhaft_Fahrleistung != 0)
  
  PLZ2 <- Große_Datenbank2 %>% 
    filter(Postleitzahl == zip_code2 & Komponente_Fehlerhaft_Fahrleistung != 0)
  
  # Create box plot with plotly
  output$boxplot_left <- renderPlotly({
      p1 <- plot_ly(PLZ1, x = ~Postleitzahl, y = ~Komponente_Fehlerhaft_Fahrleistung, 
                    type = 'box', 
                    name = paste("Boxplot für", zip_code1), 
                    marker = list(color = 'lightsteelblue')) %>%
        layout(title = paste("Boxplot für", zip_code1),
               xaxis = list(title = "Postleitzahl"),
               yaxis = list(title = "Fahrleistung (km)"))
      
      p1
    })
    
    output$boxplot_right <- renderPlotly({
      p2 <- plot_ly(PLZ2, x = ~Postleitzahl, y = ~Komponente_Fehlerhaft_Fahrleistung, 
                    type = 'box', 
                    name = paste("Boxplot für", zip_code2), 
                    marker = list(color = 'lightsteelblue')) %>%
        layout(title = paste("Boxplot für", zip_code2),
               xaxis = list(title = "Postleitzahl"),
               yaxis = list(title = "Fahrleistung (km)"))
      
      p2
    })
})
}
```

## Run der Shiny-Applikation

```{r, eval=FALSE, include=TRUE}
shinyApp(ui, server)
```

## Ergebnisse
In diesem letzten Abschnitt zeigen wir den resultierenden Inhalt unserer Shiny App und schließen mit einer Diskussion der Ergebnisse ab. 

### Heatmap
Die Heatmap erlaubt es dem Nutzer, sich auf der Deutschlandkarte zu bewegen, um zu sehen, wo sich die am meisten betroffenen Autos befinden. Die Heatmap ist interaktiv und der Nutzer kann nach Belieben hinein- und herauszoomen.

### Produktionsmengen
Im zweiten Tab können die Fahrzeuglhersteller der 4 OEM-Werke für jeden beliebigen Zeitraum die Anzahl der in diesem Zeitraum produzierten Fahrzeuge mit Mängeln überprüfen. Der Hersteller kann diese Informationen auf der Ebene der Komponenten oder der Einzelteile überprüfen. Die Grafik zeigt dann die Anzahl der betroffenen Fahrzeuge von jedem OEM Werk, das Histogramm ist auch nach dem betroffenen Bauteil oder Einzelteil gefärbt. 

### Nutzungsdauervergleich
Im Nutzungsdauer - Vergleich Tab können zwei Gemeinden ausgewählt werden und damit werden zwei Boxplots generiert zum Vergleich der reklamierten Karosserieteile der jeweiligen Gemeinde. Die Boxplots sind interaktiv, wenn man mit dem Mauszeigerdarüber fahren, werden weitere nützliche Daten angezeigt, wie zum Beispiel der Maximalwert, Minimalwert, Median...

### Fahrzeugsuche
In diesem Tab kann ein Fahrzeughalter durch seine Fahrzeug-ID prüfen ob sein Auto betroffen ist. 

### Datensatztabelle
Schließlich wird auf diesem Tab der endgültige Dataframe, oder "Datenbank", wie wir sie genannt haben, angezeigt. 

### Ergebnissdiskussion
